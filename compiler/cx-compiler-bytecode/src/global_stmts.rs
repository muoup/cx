use crate::aux_routines::allocate_variable;
use crate::builder::BytecodeBuilder;
use crate::instruction_gen::generate_instruction;
use cx_data_bytecode::types::{BCType, BCTypeKind};
use cx_data_bytecode::{BCFunctionPrototype, BCGlobalType, BCGlobalValue, BCParameter, LinkageType, VirtualInstruction};
use cx_data_typechecker::ast::{TCExpr, TCGlobalVariable};
use cx_data_typechecker::cx_types::CXFunctionPrototype;
use cx_util::mangling::mangle_destructor;

pub(crate) fn generate_function(
    builder: &mut BytecodeBuilder,
    prototype: &CXFunctionPrototype,
    body: &TCExpr
) -> Option<()> {
    builder.push_scope();

    let bc_prototype = builder.convert_cx_prototype(prototype).unwrap();
    builder.new_function(bc_prototype.clone());

    generate_params(builder, &prototype, &bc_prototype)?;

    let Some(_) = generate_instruction(builder, body) else {
        panic!("Failed to generate body for function {}", prototype.name.as_str());
    };

    builder.pop_scope();
    builder.finish_function();

    Some(())
}

pub(crate) fn generate_destructor(
    builder: &mut BytecodeBuilder,
    type_name: &str,
    body: &TCExpr
) -> Option<()> {
    let destructor_name = mangle_destructor(type_name);
    let prototype = BCFunctionPrototype {
        return_type: BCType::unit(),
        name: destructor_name,
        params: vec![BCParameter {
            name: Some("this".to_string()),
            _type: BCType::from(BCTypeKind::Pointer {
                nullable: false,
                dereferenceable: 0,
            }),
        }],
        var_args: false,
        linkage: LinkageType::Public
    };

    builder.push_scope();
    builder.new_function(prototype);

    let this = builder.add_instruction(
        VirtualInstruction::FunctionParameter {
            param_index: 0,
        },
        BCType::default_pointer()
    )?;

    builder.insert_symbol("this".to_string(), this);

    let Some(_) = generate_instruction(builder, body) else {
        panic!("Failed to generate body for destructor: {type_name}");
    };

    builder.pop_scope();
    builder.finish_function();

    Some(())
}

fn generate_params(
    builder: &mut BytecodeBuilder,
    prototype: &CXFunctionPrototype,
    bc_prototype: &BCFunctionPrototype
) -> Option<()> {
    let hidden_params_count = bc_prototype.params.len() - prototype.params.len();
    
    // Additional hidden parameters generated by the compiler
    for i in 0..hidden_params_count {
        let param = &bc_prototype.params[i];
        let memory = builder.add_instruction(
            VirtualInstruction::Allocate {
                _type: param._type.clone(),
                alignment: param._type.alignment(),
            },
            BCType::default_pointer()
        )?;

        let value = builder.add_instruction(
            VirtualInstruction::FunctionParameter {
                param_index: i as u32
            },
            param._type.clone()
        )?;

        builder.add_instruction(
            VirtualInstruction::Store { value, memory, type_: param._type.clone() },
            BCType::unit()
        )?;

        if let Some(name) = &param.name {
            builder.insert_symbol(name.clone(), memory);
        }
    }

    for (i, param) in prototype.params.iter().enumerate() {
        let i = i + hidden_params_count;
        
        if let Some(name) = &param.name {
            let memory = allocate_variable(name.as_str(), builder, &param._type)?;
            let value = builder.add_instruction(
                VirtualInstruction::FunctionParameter {
                    param_index: i as u32
                },
                BCType::default_pointer()
            )?;
            
            let param_type = builder.convert_cx_type(&param._type)?;
            
            builder.add_instruction(
                VirtualInstruction::Store {
                    value, memory,
                    type_: param_type
                },
                BCType::unit()
            )?;
        }
    }

    Some(())
}

pub(crate) fn generate_global_variable(builder: &mut BytecodeBuilder, var: &TCGlobalVariable) -> Option<()> {
    match var {
        TCGlobalVariable::UnaddressableConstant { .. } => (),

        TCGlobalVariable::StringLiteral { name, value} => {
            let value = BCGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Static,
                _type: BCGlobalType::StringLiteral(value.clone())
            };

            builder.insert_global_symbol(value);
        },

        TCGlobalVariable::Variable { name, _type, initializer } => {
            let _type = builder.convert_cx_type(_type)?;
            let value = BCGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Public,
                _type: BCGlobalType::Variable {
                    initial_value: initializer.clone(),
                    _type: _type.clone(),
                }
            };

            builder.insert_global_symbol(value);
        },
    }

    Some(())
}