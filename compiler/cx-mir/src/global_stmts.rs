use crate::aux_routines::allocate_variable;
use crate::builder::MIRBuilder;
use crate::instruction_gen::generate_instruction;
use cx_mir_data::types::MIRType;
use cx_mir_data::{
    LinkageType, MIRFunctionPrototype, MIRGlobalType, MIRGlobalValue, MIRValue, VirtualInstruction,
};
use cx_typechecker_data::ast::{TCExpr, TCGlobalVariable};
use cx_typechecker_data::cx_types::CXFunctionPrototype;

pub(crate) fn generate_function(
    builder: &mut MIRBuilder,
    prototype: &CXFunctionPrototype,
    body: &TCExpr,
) -> Option<()> {
    builder.push_scope();

    let bc_prototype = builder.convert_cx_prototype(prototype).unwrap();
    builder.new_function(bc_prototype.clone());

    generate_params(builder, prototype, &bc_prototype)?;

    let Some(_) = generate_instruction(builder, body) else {
        panic!(
            "Failed to generate body for function {}",
            prototype.name.as_str()
        );
    };

    builder.pop_scope();
    builder.finish_function();

    Some(())
}

fn generate_params(
    builder: &mut MIRBuilder,
    prototype: &CXFunctionPrototype,
    bc_prototype: &MIRFunctionPrototype,
) -> Option<()> {
    let hidden_params_count = bc_prototype.params.len() - prototype.params.len();

    // Additional hidden parameters generated by the compiler
    for i in 0..hidden_params_count {
        let param = &bc_prototype.params[i];
        let memory = builder.add_instruction(
            VirtualInstruction::Allocate {
                _type: param._type.clone(),
                alignment: param._type.alignment(),
            },
            MIRType::default_pointer(),
        )?;

        builder.add_instruction(
            VirtualInstruction::Store {
                value: MIRValue::ParameterRef(i as u32),
                memory: memory.clone(),
                type_: param._type.clone(),
            },
            MIRType::unit(),
        )?;

        if let Some(name) = &param.name {
            builder.insert_symbol(name.clone(), memory);
        }
    }

    for (i, param) in prototype.params.iter().enumerate() {
        let i = i + hidden_params_count;

        if let Some(name) = &param.name {
            let memory = allocate_variable(name.as_str(), builder, &param._type)?;
            let param_type = builder.convert_cx_type(&param._type)?;

            builder.add_instruction(
                VirtualInstruction::Store {
                    value: MIRValue::ParameterRef(i as u32),
                    memory,
                    type_: param_type,
                },
                MIRType::unit(),
            )?;
        }
    }

    Some(())
}

pub(crate) fn generate_global_variable(
    builder: &mut MIRBuilder,
    var: &TCGlobalVariable,
) -> Option<()> {
    match var {
        TCGlobalVariable::UnaddressableConstant { .. } => (),

        TCGlobalVariable::StringLiteral { name, value } => {
            let value = MIRGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Static,
                _type: MIRGlobalType::StringLiteral(value.clone()),
            };

            builder.insert_global_symbol(value);
        }

        TCGlobalVariable::Variable {
            name,
            _type,
            initializer,
        } => {
            let _type = builder.convert_cx_type(_type)?;
            let value = MIRGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Standard,
                _type: MIRGlobalType::Variable {
                    initial_value: *initializer,
                    _type: _type.clone(),
                },
            };

            builder.insert_global_symbol(value);
        }
    }

    Some(())
}
