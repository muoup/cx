use crate::aux_routines::allocate_variable;
use crate::builder::MIRBuilder;
use crate::instruction_gen::generate_instruction;
use cx_mir_data::types::{MIRType, MIRTypeKind};
use cx_mir_data::{MIRFunctionPrototype, MIRGlobalType, MIRGlobalValue, MIRParameter, LinkageType, VirtualInstruction, MIRValue};
use cx_typechecker_data::ast::{TCExpr, TCGlobalVariable};
use cx_typechecker_data::cx_types::CXFunctionPrototype;
use cx_util::mangling::mangle_destructor;

pub(crate) fn generate_function(
    builder: &mut MIRBuilder,
    prototype: &CXFunctionPrototype,
    body: &TCExpr
) -> Option<()> {
    builder.push_scope();

    let bc_prototype = builder.convert_cx_prototype(prototype).unwrap();
    builder.new_function(bc_prototype.clone());

    generate_params(builder, prototype, &bc_prototype)?;

    let Some(_) = generate_instruction(builder, body) else {
        panic!("Failed to generate body for function {}", prototype.name.as_str());
    };

    builder.pop_scope();
    builder.finish_function();

    Some(())
}

pub(crate) fn generate_destructor(
    builder: &mut MIRBuilder,
    type_name: &str,
    body: &TCExpr
) -> Option<()> {
    let destructor_name = mangle_destructor(type_name);
    let prototype = MIRFunctionPrototype {
        return_type: MIRType::unit(),
        name: destructor_name,
        params: vec![MIRParameter {
            name: Some("this".to_string()),
            _type: MIRType::from(MIRTypeKind::Pointer {
                nullable: false,
                dereferenceable: 0,
            }),
        }],
        var_args: false,
        linkage: LinkageType::Standard
    };

    builder.push_scope();
    builder.new_function(prototype);

    builder.insert_symbol("this".to_string(), MIRValue::ParameterRef(0));

    let Some(_) = generate_instruction(builder, body) else {
        panic!("Failed to generate body for destructor: {type_name}");
    };

    builder.pop_scope();
    builder.finish_function();

    Some(())
}

fn generate_params(
    builder: &mut MIRBuilder,
    prototype: &CXFunctionPrototype,
    bc_prototype: &MIRFunctionPrototype
) -> Option<()> {
    let hidden_params_count = bc_prototype.params.len() - prototype.params.len();
    
    // Additional hidden parameters generated by the compiler
    for i in 0..hidden_params_count {
        let param = &bc_prototype.params[i];
        let memory = builder.add_instruction(
            VirtualInstruction::Allocate {
                _type: param._type.clone(),
                alignment: param._type.alignment(),
            },
            MIRType::default_pointer()
        )?;

        builder.add_instruction(
            VirtualInstruction::Store {
                value: MIRValue::ParameterRef(i as u32),
                memory: memory.clone(),
                type_: param._type.clone()
            },
            MIRType::unit()
        )?;

        if let Some(name) = &param.name {
            builder.insert_symbol(name.clone(), memory);
        }
    }

    for (i, param) in prototype.params.iter().enumerate() {
        let i = i + hidden_params_count;

        if let Some(name) = &param.name {
            let memory = allocate_variable(name.as_str(), builder, &param._type)?;
            let param_type = builder.convert_cx_type(&param._type)?;
            
            builder.add_instruction(
                VirtualInstruction::Store {
                    value: MIRValue::ParameterRef(i as u32),
                    memory,
                    type_: param_type
                },
                MIRType::unit()
            )?;
        }
    }

    Some(())
}

pub(crate) fn generate_global_variable(builder: &mut MIRBuilder, var: &TCGlobalVariable) -> Option<()> {
    match var {
        TCGlobalVariable::UnaddressableConstant { .. } => (),

        TCGlobalVariable::StringLiteral { name, value} => {
            let value = MIRGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Static,
                _type: MIRGlobalType::StringLiteral(value.clone())
            };

            builder.insert_global_symbol(value);
        },

        TCGlobalVariable::Variable { name, _type, initializer } => {
            let _type = builder.convert_cx_type(_type)?;
            let value = MIRGlobalValue {
                name: name.clone(),
                linkage: LinkageType::Standard,
                _type: MIRGlobalType::Variable {
                    initial_value: *initializer,
                    _type: _type.clone(),
                }
            };

            builder.insert_global_symbol(value);
        },
    }

    Some(())
}