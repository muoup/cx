import std::optional;

public:

template <T : type>
struct vector {
    T* data;
    usize length;
    usize capacity;
}

template <T : type>
vector<T> vector<T>::new() {
    return vector<T> {
        .data = 0,
        .length = 0,
        .capacity = 0
    };
}

template <T : type>
vector<T> vector<T>::with_capacity(usize capacity) {
    return vector<T> {
        .data = malloc(capacity * sizeof(T)),
        .length = 0,
        .capacity = capacity
    }
}

template <T : type>
void vector<T>::push(this, T object) {
    if (this->length < this->capacity) {
        this->data[this->length] = object;
        this->length++;
        return;
    }

    this->capacity = this->capacity * 2 + 1;
    this->data = realloc(this->data, this->capacity * sizeof(T));
}

template <T : type>
T* vector<T>::at(this, usize index) -> @optional(none = NULL) {
    if (index >= this->length) {
        return None;
    }

    return &this->data[index];
}