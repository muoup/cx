import std::optional;
import std::memory;

public:

struct vector<T> {
    T strong[length]* data;
    u64 length;
    u64 capacity;
}

vector<T> vector::new<T>() {
    return vector<T> {
        .data = 0,
        .length = 0,
        .capacity = 0
    };
}

vector<T> vector::with_capacity<T>(u64 capacity) {
    return vector<T> {
        .data = malloc(capacity * sizeof(T)),
        .length = 0,
        .capacity = capacity
    }
}

void vector<T>::push(this, T object) {
    if (this->length < this->capacity) {
        this->data[this->length] = object;
        this->length++;
        return;
    }

    this->capacity = this->capacity * 2 + 1;
    this->data = realloc(this->data, this->capacity * sizeof(T));
}

optional<T> vector<T>::at(this, u64 index) {
    if (index >= this->length) {
        return null;
    }

    return this->data[index];
}

void vector<T>::sort(this) where T is Ordered {
    this.__internal_sort(0, this->length - 1);
}

private:

void vector<T>::__internal_sort(this, u64 left, u64 right)
    where T is Ordered {
    if (left >= right) {
        return;
    }

    u64 pivot = this.__partition(left, right);

    this.__internal__sort(left, pivot - 1);
    this.__internal__sort(pivot + 1, right);
}

void vector<T>::__internal_partition(this, u64 left, u64 right)
    where T is Ordered {

    T pivot = this->data[right];
    u64 i = left - 1;

    for (u64 j = left; j < right; j++) {
        if (this->data[j] < pivot) {
            i++;
            T temp = this->data[i];
            this->data[i] = this->data[j];
            this->data[j] = temp;
        }
    }
}